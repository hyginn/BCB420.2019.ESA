# sequenceAnalysisESA.R
#
# Purpose: Exploratory System Analysis tool project for BCB420 2019
# Version: 1.0.0
# Version history: 1.0.0
# Date: March 24 2019
# Author: Heewon Lee (heewon.lee@mail.utoronto.ca)
# License: MIT
#
# Input: A HGNC symbol that the user would like to retrieve
# the corresponding protein sequence alignments with it's interacting
# genes according to the STRING database
# Output: A dataframe or a .tsv file containing the multiple sequence alignment data
# of each pairwise alignment
# Dependencies: devtools, BCB420.2019.PDB, BiocManager, Biostrings, msa

# ====  FUNCTION  =============================================================
# sequenceAnalysisESA.R
#'
#' \code{sequenceAnalysisESA} Return a data frame containing the alignment data
#'    between the provided hgnc gene and it's corresponding genes based
#'    on the STRING database..
#'
#' @param hgnc The hgnc symbol of the gene of interest in the form of a
#'     string. This hgnc gene will have multiple sequence
#'     alignments being performed on it with all of it's interacting
#'     proteins based off the STRING database.
#' @return A data frame including the hgnc gene of interest,
#'     the gene it is being compared to, the protein sequence of
#'     each resulting protein generated by the genes and
#'     the consensus sequence and conservation scores based
#'     off a ClustalW multiple Sequence Alignment.
#' @author {Heewon Lee} (aut)
#' @examples
#' # Picking a sample hgnc symbol to get the corresponding protein alignments
#' # with it's interacting genes
#' hgnc <- "BECN1"
#'
#' # Call the getAlignments helper function to generate the dataframe
#' result <- sequenceAnalysis(hgnc)
#' # If the user would like, the resulting data frame can be stored
#' # in a .tsv file which can be imported into the environment by the
#' # user
#'
#' @export

sequenceAnalysis <- function(hgnc) {

  # Load all required packages.

  # Import geneList, HGNC, STRINGedges, and fetchComponents() from git repo
  # from https://github.com/judyheewonlee/BCB420.2019.ESA made
  # by Professor Boris Steipe (forked directory, master repo
  # can be accessed from https://github.com/hyginn/BCB420.2019.ESA)

  # Load HGNC data
  myURL <- paste0("https://github.com/hyginn/",
                  "BCB420-2019-resources/blob/master/HGNC.RData?raw=true")
  load(url(myURL))  # loads HGNC data frame

  # Load geneList
  myURL <- paste0("http://steipe.biochemistry.utoronto.ca/abc/assets/",
                  "geneList-2019-03-13.RData")
  load(url(myURL))  # loads GTRD geneList object

  # Load STRINGedges
  myURL <- paste0("http://steipe.biochemistry.utoronto.ca/abc/assets/",
                  "STRINGedges-2019-03-14.RData")
  load(url(myURL))  # loads STRING edges object

  # Source fetchComponents
  fetchComponents <- function(sys) {
    # returns a fixed set of symbols.
    # Function stub for development purposes only.
    if (sys == "PHALY") {
      s <- c("AMBRA1", "ATG14", "ATP2A1", "ATP2A2", "ATP2A3", "BECN1", "BECN2",
             "BIRC6", "BLOC1S1", "BLOC1S2", "BORCS5", "BORCS6", "BORCS7",
             "BORCS8", "CACNA1A", "CALCOCO2", "CTTN", "DCTN1", "EPG5", "GABARAP",
             "GABARAPL1", "GABARAPL2", "HDAC6", "HSPB8", "INPP5E", "IRGM",
             "KXD1", "LAMP1", "LAMP2", "LAMP3", "LAMP5", "MAP1LC3A", "MAP1LC3B",
             "MAP1LC3C", "MGRN1", "MYO1C", "MYO6", "NAPA", "NSF", "OPTN",
             "OSBPL1A", "PI4K2A", "PIK3C3", "PLEKHM1", "PSEN1", "RAB20", "RAB21",
             "RAB29", "RAB34", "RAB39A", "RAB7A", "RAB7B", "RPTOR", "RUBCN",
             "RUBCNL", "SNAP29", "SNAP47", "SNAPIN", "SPG11", "STX17", "STX6",
             "SYT7", "TARDBP", "TFEB", "TGM2", "TIFA", "TMEM175", "TOM1",
             "TPCN1", "TPCN2", "TPPP", "TXNIP", "UVRAG", "VAMP3", "VAMP7",
             "VAMP8", "VAPA", "VPS11", "VPS16", "VPS18", "VPS33A", "VPS39",
             "VPS41", "VTI1B", "YKT6")
    } else {
      s <- ""
    }
    return(s)
  }

  phaly <- fetchComponents("PHALY")

  ### ============= Setting up PDB-HGNC database ========================== ###

  # Install required packages
  install_github("judyheewonlee/BCB420.2019.PDB")

  if (!requireNamespace("devtools", quietly = TRUE)) {
    install.packages("devtools")
    library(devtools)
  }

  if (!requireNamespace("data.table", quietly = TRUE)) {
    install.packages("data.table")
  }

  if (!requireNamespace("xml2", quietly = TRUE)) {
    install.packages("xml2")
  }

  if (! requireNamespace("BiocManager", quietly = TRUE)) {
    install.packages("BiocManager")
  }

  if (!requireNamespace("rtracklayer", quietly = TRUE)) {
    BiocManager::install("rtracklayer")
  }

  if (! requireNamespace("biomaRt", quietly = TRUE)) {
    BiocManager::install("biomaRt")
  }

  if (!requireNamespace("msa", quietly = TRUE)) {
    BiocManager::install("msa", version = "3.8")
  }

  if (!requireNamespace("Biostrings", quietly = TRUE)) {
    BiocManager::install("Biostrings", version = "3.8")
  }

  source(file.path(.libPaths(),
                   "BCB420.2019.PDB", "scripts/PDBdataset.R"))
  source(file.path(.libPaths(),
                   "BCB420.2019.PDB", "scripts/getData.R"))
  source(file.path(.libPaths(),
                   "BCB420.2019.PDB", "scripts/addHGNC.R"))
  source(file.path(.libPaths(),
                   "BCB420.2019.PDB", "scripts/addTranscripts.R"))
  source(file.path(.libPaths(),
                   "BCB420.2019.PDB", "scripts/addpdbChain.R"))
  source(file.path(.libPaths(),
                   "BCB420.2019.PDB", "scripts/addPDB.R"))
  source(file.path(.libPaths(),
                   "BCB420.2019.PDB", "scripts/addPDBData.R"))
  source(file.path(.libPaths(),
                   "BCB420.2019.PDB", "scripts/fetchPDBXML.R"))
  source(file.path(.libPaths(),
                   "BCB420.2019.PDB", "scripts/readXML.R"))

  pdbHGNC <- PDBdataset()

  # Get the hgnc symbols that interact with the provided hgnc gene
  # using the STRING database
  edges <- STRINGedges[STRINGedges$a == hgnc,]

  hgncTable <- pdbHGNC$Transcripts[pdbHGNC$Transcripts$hgncID
                                   %in% edges$b,c("ID", "hgncID")]

  hgncTable <- rbind(hgncTable, pdbHGNC$Transcripts[pdbHGNC$Transcripts$hgncID
                                              == hgnc, c("ID", "hgncID")])

  hgncTable$Sequence <- NA
  hgncTable$Resolution <- NA


  # Pick the chain with the best resolution if there are overlapping
  # PDB protein structures
  for (transcript in hgncTable$ID) {
    sel <- pdbHGNC$pdbChains[pdbHGNC$pdbChains$transcriptHGNC == transcript,]
    edgeSeq <- sel[sel$Resolution == min(sel$Resolution),
                   ][1,c("Resolution", "Sequences")]
    hgncTable[hgncTable$ID == transcript,]$Sequence <- edgeSeq$Sequences
    hgncTable[hgncTable$ID == transcript,]$Resolution <- edgeSeq$Resolution

  }

  # Perform an MSA using the Bioconductor msa package in order to retrieve
  # the sequence alignments between the provided hgnc protein and
  # all protein chain sequences it interacts with according to the
  # STRING database
  result <- data.frame()

  tempDF <- data.frame(a = NA,
                       b = NA,
                       SequenceA = NA,
                       SequenceB = NA,
                       Consensus = NA,
                       Score = NA)

  mainTranscript <- hgncTable[hgncTable$hgncID == hgnc,]

  # Compare all protein chains of the gene of interest
  # with all the other protein chains it interacts with
  # using the msa package
  for (a in mainTranscript$ID) {
    tempDF$a <- a
    seqA <- mainTranscript[mainTranscript$ID == a, "Sequence"]

    tempDF$SequenceA <- seqA

    for (b in hgncTable$ID) {
      tempDF$b <- b
      seqB <- hgncTable[hgncTable$ID == b, "Sequence"]

      tempDF$SequenceB <- seqB

      # import BLOSUM62 scoring matrix from Biostrings package from
      # Bioconductor

      data("BLOSUM62")

      myMSA <- msa::msaClustalW(c(seqA, seqB), type="protein")
      myConsensus <- msa::msaConsensusSequence(msa)
      myScore <- msa::msaConservationScore(msa, BLOSUM62)

      tempDF$Consensus <- myConsensus
      tempDF$Score <- as.list(as.data.frame(myScore))

      result <- rbind(result, tempDF)

    }

  }

  return(result)
}


# [END]
